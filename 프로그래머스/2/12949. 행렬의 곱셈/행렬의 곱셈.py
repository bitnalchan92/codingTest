def solution(arr1, arr2):
    # 입력값으로 들어온 두 리스트의 길이 (결과값일 될 리스트의 크기를 결정하기 위해 가져옴)
    arr1_row, arr1_col = len(arr1), len(arr1[0])
    arr2_row, arr2_col = len(arr2), len(arr2[0])
    
    # 반환될 행렬 ( 반환될 행렬의 크기는 행렬 곱셈 방법 참고 )
    # 3행 2열 * 2행 2열의 경우 => 결과는 3행 2열
    # 4행 2열 * 2행 4열의 경우 => 결과는 4행 4열
    # 곱할때 앞의 행렬의 열과 뒤의 행렬의 행이 동일해야 곱할 수 있다. (문제 조건에 곱할 수 있는 배열만 주어진다고 나와있음)
    ret = [[0] * arr2_col for _ in range(arr1_row)] # [[0, 0], [0, 0], [0, 0]] 
    
    for i in range(arr1_row):
        for j in range(arr2_col):
            # (arr1[0][0] * arr2의 [0][0]) + ( arr1의 [0][1] * arr2의 [1][0]) 이게 ret[0][0]으로!
            # 그 다음 생각할게,,, 2중for문으로 해결이 가능한가?
            # ret에 값을 저장하기 위해서 i, j만을 사용한다면 문제가 없나?
            # i, j만 쓴다면, ret[0][0]에 보관할수가 없다. 내부의 for문을 한번 순회해도 값이 하나 변경되기 때문에,,, 결과적으로 불가능
            # 3중for문을 쓴다면...
            # 행렬의 곱셈 규칙에 따라, 첫번째 행렬의 열의 수 또는 두번째 행렬의 행의 수만큼은 반복을 해야함 (이 수가 같아야만 곱셈이 가능함)
            for k in range(arr1_col): 
                # 이렇게 된다면? 
                # (arr1[0][0] * arr2의 [0][0]) + ( arr1의 [0][1] * arr2의 [1][0]) 이게 ret[0][0]이 충족될듯.
                ret[i][j] += arr1[i][k] * arr2[k][j] 
                
    return ret